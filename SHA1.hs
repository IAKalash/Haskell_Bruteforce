import Data.Word(Word32)
import Data.Bits (Bits, rotate, xor, (.&.), (.|.))
import qualified Data.ByteString as BS 
import Data.ByteString.Internal (c2w)
import Numeric (showHex)
{-Функция SHA1(сообщение):
    // 1. Дополнение сообщения (padding)
    исходная_длина = длина(сообщение) в битах
    добавить_бит_1 к сообщению
    добавить_нули до длины % 512 == 448
    добавить_64_бита(исходная_длина) // длина в конце
    
    // 2. Разбиение на блоки по 512 бит (64 байта)
    блоки = разбить_сообщение_на_блоки(512 бит)
    
    // 3. Инициализация регистров (5 x 32 бита)
    H0 = 0x67452301
    H1 = 0xEFCDAB89
    H2 = 0x98BADCFE
    H3 = 0x10325476
    H4 = 0xC3D2E1F0
    
    // 4. Основной цикл по блокам
    Для каждого блока в блоки:
        // Разделить блок на 16 слов по 32 бита
        слова = разбить_блок_на_слова(блок, 16)
        
        // Расширение до 80 слов
        Для i от 16 до 79:
            слова[i] = лево_сдвиг((слова[i-3] XOR слова[i-8] XOR слова[i-14] XOR слова[i-16]), 1)
        
        // Сохранить исходные значения
        A = H0
        B = H1
        C = H2
        D = H3
        E = H4
        
        // 80 шагов обработки (4 раунда по 20 шагов)
        Для i от 0 до 79:
            Если i < 20:
                F = (B И C) ИЛИ ((НЕ B) И D)
                K = 0x5A827999
            Иначе Если i < 40:
                F = B XOR C XOR D
                K = 0x6ED9EBA1
            Иначе Если i < 60:
                F = (B И C) ИЛИ (B И D) ИЛИ (C И D)
                K = 0x8F1BBCDC
            Иначе:
                F = B XOR C XOR D
                K = 0xCA62C1D6
            
            // Обновление регистров
            temp = лево_сдвиг(A, 5) + F + E + K + слова[i]
            E = D
            D = C
            C = лево_сдвиг(B, 30)
            B = A
            A = temp
        
        // Прибавить к исходным значениям
        H0 = H0 + A
        H1 = H1 + B
        H2 = H2 + C
        H3 = H3 + D
        H4 = H4 + E
    
    // 5. Вывод хеша
    хеш = объединить(H0, H1, H2, H3, H4) // 160 бит
    Вернуть хеш-}

-- начальные значения регистров
initH :: [Word32]
initH = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]

--константы K для каждого раунда
k :: Int -> Word32
k t
  | t < 20  = 0x5A827999
  | t < 40  = 0x6ED9EBA1
  | t < 60  = 0x8F1BBCDC
  | otherwise = 0xCA62C1D6

f:: Int -> Word32 -> Word32 -> Word32 -> Word32
f t b c d 
    | t < 20 = (b .&. c) .|. ((complement b).&. d)
    | t < 40 =  b `xor` c `xor` d
    | t < 60 = (b .&. c) .|. (b .&. d) .|. (c .&. d)
    | otherwise = b `xor` c `xor` d